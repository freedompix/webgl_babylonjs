<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>URBAN:JUNGLE</title>
    <!--- Link to the last version of BabylonJS ---> 
	
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
	 <!--- <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>--->

    <style>
        html, body {
            overflow: hidden;
            width   : 100%;
            height  : 100%;
            margin  : 0;
            padding : 0;
			background-color: #E6E6D9;
        }

        #renderCanvas {
            width   : 100%;
            height  : 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
<audio id="soundBG" autoplay style="display: hidden;">
  <source src="http://ice4.somafm.com/spacestation-128-mp3" type="audio/mpeg" >
</audio>



    <canvas id="renderCanvas"></canvas>
    <script>
	var timer=0;
	var loadingStatusNeon=0;
	var loadingStatusTemple=0;
	var loadingStatusPalms=0;
	console.log(window.loadingStatusTemple);
	
	
window.addEventListener('DOMContentLoaded', function(){
		

document.getElementById('soundBG').play();		

            // get the canvas DOM element
            var canvas = document.getElementById('renderCanvas');

            // load the 3D engine
            var engine = new BABYLON.Engine(canvas, true);

            // createScene function that creates and return the scene
            var createScene = function(){
                // create a basic BJS Scene object
                var scene = new BABYLON.Scene(engine);
				
				
			//	scene.debugLayer.show();

                // create a FreeCamera, and set its position to (x:0, y:5, z:-10)
                var camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, -5,-25), scene);

                // target the camera to scene origin
                camera.setTarget(BABYLON.Vector3.Zero());
				camera.fov=1.5;

                // attach the camera to the canvas
                camera.attachControl(canvas, false);
				
				
//var camera2 = new BABYLON.WebVRFreeCamera("camera2", new BABYLON.Vector3(0, 0, 0), scene);			
//camera2.setTarget(BABYLON.Vector3.Zero());
//camera2.fov=1.5;				
				
				
				


// scene.debugLayer.show();

     var vrHelper = scene.createDefaultVRExperience({createDeviceOrientationCamera:false});



vrHelper.onAfterEnteringVRObservable.add(()=>{
        if(scene.activeCamera === vrHelper.vrDeviceOrientationCamera){
		
            BABYLON.FreeCameraDeviceOrientationInput.WaitForOrientationChangeAsync(1000).then(()=>{
                // Successfully received sensor input
            }).catch(()=>{
                alert("Device orientation camera is being used but no sensor is found, prompt user to enable in safari settings");
            })
        }
    })
 

//fog	
scene.fogMode = BABYLON.Scene.FOGMODE_EXP;		
scene.fogColor = new BABYLON.Color3(0.9, 0.9, 0.85);
scene.fogDensity = 0.015;
scene.clearColor = new BABYLON.Color3(0.9, 0.9, 0.85);

//abberation
var parameters = {  edge_blur: 5.0,  chromatic_aberration: 2.0,  distortion: 0.3,};
var lensEffect = new BABYLON.LensRenderingPipeline('lensEffects', parameters, scene, 1.0, camera);
scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline('lensEffects', camera);

//abberationVR
var lensEffectVR = new BABYLON.LensRenderingPipeline('lensEffectsVR', parameters, scene, 1.0, vrHelper.vrDeviceOrientationCamera);
scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline('lensEffectsVR', vrHelper.vrDeviceOrientationCamera);

scene.imageProcessingConfiguration.contrast = 3.0;
scene.imageProcessingConfiguration.exposure = 1.2;





	
	
        // Set up new rendering pipeline
        var pipeline = new BABYLON.DefaultRenderingPipeline("default", true, scene);


        // Bloom
        pipeline.bloomEnabled = true;
        pipeline.bloomThreshold = 0.6;
        pipeline.bloomWeight = 0.2;
        pipeline.bloomKernel = 50;
        pipeline.bloomScale = .5;	    

        pipeline.imageProcessingEnabled = false;
		

// create a basic light, aiming 0,1,0 - meaning, to the sky
var light1 = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(-0.1,1,0.3), scene);
var light2 = new BABYLON.SpotLight("spotLight", new BABYLON.Vector3(0, 45, 10), new BABYLON.Vector3(0.3, -0.71, 0), Math.PI / 3, 2, scene);




 var myMaterial = new BABYLON.StandardMaterial("myMaterial1", scene);
 var myTexture  = new BABYLON.Texture("textures/texture.jpg", scene);
  
 myMaterial.bumpTexture = new BABYLON.Texture("textures/6.jpg", scene);
 myMaterial.diffuseTexture  = new BABYLON.Texture("textures/texture.jpg", scene); 
 myMaterial.emissiveTexture = new BABYLON.Texture("textures/texture.jpg", scene); 
 myMaterial.emissiveColor = new BABYLON.Color3.White();
 

 
scene.getMaterialByID("myMaterial1").diffuseTexture.uScale = 4.0;
scene.getMaterialByID("myMaterial1").diffuseTexture.vScale = 4.0;

scene.getMaterialByID("myMaterial1").diffuseTexture.uScale = 4.0;
scene.getMaterialByID("myMaterial1").diffuseTexture.vScale = 4.0;


 











var wall_1 = BABYLON.MeshBuilder.CreateBox("wall1", {height: 200, width: 2, depth: 200}, scene);
var wall_2 = BABYLON.MeshBuilder.CreateBox("wall2", {height: 200, width: 2, depth: 200}, scene);
var wall_3 = BABYLON.MeshBuilder.CreateBox("wall3", {height: 200, width: 2, depth: 200}, scene);
var wall_4 = BABYLON.MeshBuilder.CreateBox("wall4", {height: 200, width: 2, depth: 200}, scene);



scene.getMeshByID('wall1').position.x = -12; 
scene.getMeshByID('wall1').position.y = -3; 
scene.getMeshByID('wall1').position.z = 0; 
 
scene.getMeshByID('wall2').position.x = 12; 
scene.getMeshByID('wall2').position.y = -3;
scene.getMeshByID('wall2').position.z = 0;

scene.getMeshByID('wall3').position.x = -12; 
scene.getMeshByID('wall3').position.y = -3;
scene.getMeshByID('wall3').position.z = 200; 

scene.getMeshByID('wall4').position.x = 12; 
scene.getMeshByID('wall4').position.y = -3;
scene.getMeshByID('wall4').position.z = 200       ;





wall_1.material = myMaterial;
wall_2.material = myMaterial;
wall_3.material = myMaterial;
wall_4.material = myMaterial;










                // return the created scene
				
return scene;
				
				
				
				
            }





            // call the createScene function
            var scene = createScene(); 

////////////





            // run the render loop
engine.runRenderLoop(function(){
scene.render();
window.timer++;

document.getElementById('soundBG').play();					
				
			
scene.getMeshByID('wall1').position.z = scene.getMeshByID('wall1').position.z-0.15;  
scene.getMeshByID('wall2').position.z = scene.getMeshByID('wall2').position.z-0.15; 
scene.getMeshByID('wall3').position.z = scene.getMeshByID('wall3').position.z-0.15;  
scene.getMeshByID('wall4').position.z = scene.getMeshByID('wall4').position.z-0.15; 

if (scene.getMeshByID('wall1').position.z <= -200) scene.getMeshByID('wall1').position.z =scene.getMeshByID('wall1').position.z +400;
if (scene.getMeshByID('wall2').position.z <= -200) scene.getMeshByID('wall2').position.z =scene.getMeshByID('wall2').position.z +400;
if (scene.getMeshByID('wall3').position.z <= -200) scene.getMeshByID('wall3').position.z =scene.getMeshByID('wall3').position.z +400;
if (scene.getMeshByID('wall4').position.z <= -200) scene.getMeshByID('wall4').position.z =scene.getMeshByID('wall4').position.z +400;














});



            // the canvas/window resize event handler
            window.addEventListener('resize', function(){
                engine.resize();
				
				
            });
        });
    </script>
</body>
</html>
